// API Route for Running Penetration Tests
// Executes security tests and streams results back to the client

import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'

// Test executor functions
async function runSecurityHeadersTest(targetUrl: string) {
  const results = []
  
  try {
    const response = await fetch(targetUrl, { method: 'HEAD' })
    const headers = response.headers
    
    const requiredHeaders = {
      'strict-transport-security': 'HSTS',
      'x-frame-options': 'X-Frame-Options',
      'x-content-type-options': 'X-Content-Type-Options',
      'content-security-policy': 'CSP',
      'referrer-policy': 'Referrer-Policy',
      'permissions-policy': 'Permissions-Policy'
    }
    
    for (const [header, name] of Object.entries(requiredHeaders)) {
      const value = headers.get(header)
      results.push({
        test: `Security Header: ${name}`,
        status: value ? 'pass' : 'fail',
        message: value ? `Present: ${value.substring(0, 50)}...` : 'Missing',
        timestamp: new Date().toISOString()
      })
    }
  } catch (error) {
    results.push({
      test: 'Security Headers',
      status: 'fail',
      message: `Error: ${error}`,
      timestamp: new Date().toISOString()
    })
  }
  
  return results
}

async function runRateLimitTest(targetUrl: string) {
  const results = []
  let successCount = 0
  let rateLimitedCount = 0
  
  try {
    // Send 50 rapid requests (simplified for demo)
    for (let i = 0; i < 50; i++) {
      try {
        const response = await fetch(`${targetUrl}/api/newsletter`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email: `test${i}@example.com` })
        })
        
        if (response.status === 429) {
          rateLimitedCount++
        } else if (response.ok) {
          successCount++
        }
      } catch {
        // Ignore individual request errors
      }
      
      // Small delay to avoid overwhelming the system
      await new Promise(resolve => setTimeout(resolve, 20))
    }
    
    results.push({
      test: 'Rate Limiting',
      status: rateLimitedCount > 0 ? 'pass' : 'warning',
      message: `Success: ${successCount}, Rate Limited: ${rateLimitedCount}`,
      details: rateLimitedCount > 0 
        ? 'Rate limiting is active and blocking excess requests' 
        : 'No rate limiting detected in 50 requests',
      timestamp: new Date().toISOString()
    })
  } catch (error) {
    results.push({
      test: 'Rate Limiting',
      status: 'fail',
      message: `Error: ${error}`,
      timestamp: new Date().toISOString()
    })
  }
  
  return results
}

async function runSQLInjectionTest(targetUrl: string) {
  const results = []
  
  const sqlPayloads = [
    "' OR '1'='1",
    "'; DROP TABLE users--",
    "' UNION SELECT NULL--",
    "admin'--",
    "' OR 1=1--"
  ]
  
  let vulnerableCount = 0
  let blockedCount = 0
  
  for (const payload of sqlPayloads) {
    try {
      const response = await fetch(`${targetUrl}/api/newsletter`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: `${payload}@test.com` })
      })
      
      if (response.ok) {
        vulnerableCount++
      } else if (response.status === 403 || response.status === 400) {
        blockedCount++
      }
    } catch {
      blockedCount++
    }
  }
  
  results.push({
    test: 'SQL Injection',
    status: vulnerableCount === 0 ? 'pass' : 'fail',
    message: `Blocked: ${blockedCount}/${sqlPayloads.length}, Vulnerable: ${vulnerableCount}/${sqlPayloads.length}`,
    details: vulnerableCount > 0 
      ? 'SQL injection may be possible - payloads were accepted' 
      : 'All SQL injection attempts were blocked or sanitized',
    timestamp: new Date().toISOString()
  })
  
  return results
}

async function runXSSTest(targetUrl: string) {
  const results = []
  
  const xssPayloads = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg/onload=alert('XSS')>",
    "javascript:alert('XSS')"
  ]
  
  let vulnerableCount = 0
  let blockedCount = 0
  
  for (const payload of xssPayloads) {
    try {
      const response = await fetch(`${targetUrl}/api/newsletter`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: `${payload}@test.com` })
      })
      
      if (response.ok) {
        vulnerableCount++
      } else if (response.status === 403 || response.status === 400) {
        blockedCount++
      }
    } catch {
      blockedCount++
    }
  }
  
  results.push({
    test: 'XSS Protection',
    status: vulnerableCount === 0 ? 'pass' : 'warning',
    message: `Blocked: ${blockedCount}/${xssPayloads.length}, Accepted: ${vulnerableCount}/${xssPayloads.length}`,
    details: vulnerableCount > 0 
      ? 'XSS payloads accepted - verify if properly sanitized' 
      : 'All XSS attempts were blocked',
    timestamp: new Date().toISOString()
  })
  
  return results
}

async function runAuthBypassTest(targetUrl: string) {
  const results = []
  
  const protectedRoutes = [
    '/dashboard',
    '/admin',
    '/protected',
    '/api/monitoring'
  ]
  
  let protectedCount = 0
  let accessibleCount = 0
  
  for (const route of protectedRoutes) {
    try {
      const response = await fetch(`${targetUrl}${route}`, {
        redirect: 'manual' // Don't follow redirects
      })
      
      // 401, 403, or 307 (redirect) means protected
      if (response.status === 401 || response.status === 403 || response.status === 307) {
        protectedCount++
      } else if (response.ok) {
        accessibleCount++
      }
    } catch {
      protectedCount++ // Error likely means protected
    }
  }
  
  results.push({
    test: 'Auth Bypass',
    status: accessibleCount === 0 ? 'pass' : 'fail',
    message: `Protected: ${protectedCount}/${protectedRoutes.length}, Accessible: ${accessibleCount}/${protectedRoutes.length}`,
    details: accessibleCount > 0 
      ? 'Some protected routes are accessible without authentication' 
      : 'All protected routes require authentication',
    timestamp: new Date().toISOString()
  })
  
  return results
}

export async function POST(request: NextRequest) {
  try {
    // Check if user is authenticated and is admin
    const authResult = await auth()
    const userId = authResult.userId
    
    if (!userId) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // Check admin access
    const sessionClaims = authResult.sessionClaims as any
    const email = sessionClaims?.email
    const isAdmin = email === 'superjesseray018@gmail.com'

    if (!isAdmin) {
      return NextResponse.json(
        { error: 'Forbidden - Admin access required' },
        { status: 403 }
      )
    }

    const body = await request.json()
    const { testType } = body
    
    // Get target URL (your deployed app)
    const targetUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://portfolio-app-with-authentication-owdjtrive.vercel.app'
    
    let results: any[] = []
    
    switch (testType) {
      case 'Security Headers':
        results = await runSecurityHeadersTest(targetUrl)
        break
      case 'Rate Limiting':
        results = await runRateLimitTest(targetUrl)
        break
      case 'SQL Injection':
        results = await runSQLInjectionTest(targetUrl)
        break
      case 'XSS Protection':
        results = await runXSSTest(targetUrl)
        break
      case 'Auth Bypass':
        results = await runAuthBypassTest(targetUrl)
        break
      default:
        return NextResponse.json(
          { error: 'Unknown test type' },
          { status: 400 }
        )
    }
    
    return NextResponse.json({
      success: true,
      testType,
      results,
      timestamp: new Date().toISOString()
    })
    
  } catch (error) {
    console.error('Pentest API error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// For streaming results (advanced)
export async function GET(request: NextRequest) {
  const authResult = await auth()
  if (!authResult.userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // Return available tests
  return NextResponse.json({
    availableTests: [
      'Security Headers',
      'Rate Limiting',
      'SQL Injection',
      'XSS Protection',
      'Auth Bypass',
      'Bot Detection',
      'API Security',
      'Session Management'
    ]
  })
}